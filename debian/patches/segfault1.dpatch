#!/bin/sh /usr/share/dpatch/dpatch-run

@DPATCH@
Index: openjpeg-1.5.1/libopenjpeg/tcd.c
===================================================================
--- openjpeg-1.5.1.orig/libopenjpeg/tcd.c	2012-09-13 09:58:39.000000000 +0000
+++ openjpeg-1.5.1/libopenjpeg/tcd.c	2013-01-01 01:01:01.000000000 +0000
@@ -1364,10 +1364,19 @@
 	
 	t1_time = opj_clock();	/* time needed to decode a tile */
 	t1 = t1_create(tcd->cinfo);
+	int comp0size = (tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0);
 	for (compno = 0; compno < tile->numcomps; ++compno) {
 		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
-		/* The +3 is headroom required by the vectorized DWT */
-		tilec->data = (int*) opj_aligned_malloc((((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0))+3) * sizeof(int));
+		int compcsize = ((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0));
+		/* Later-on it is assumed that all components are of at least comp0size blocks */
+		if (compcsize < comp0size)
+		{
+			opj_event_msg(tcd->cinfo, EVT_ERROR, "Error decoding tile. Component %d contains only %d blocks "
+				"while component 0 has %d blocks\n", compno, compcsize, comp0size);
+			return false;
+		}
+		/* The +3 is headroom required by the vectorized DWT */
+		tilec->data = (int*) opj_aligned_malloc((comp0size+3) * sizeof(int));
 		t1_decode_cblks(t1, tilec, &tcd->tcp->tccps[compno]);
 	}
 	t1_destroy(t1);
